using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Chuckhill2.Utilities;
using ChuckHill2.ExtensionDetector;

namespace BuildList
{
    public enum BuildListOptions
    {
        /// <summary>
        /// Build list of both text and binary files
        /// </summary>
        Both,
        /// <summary>
        /// Build list of text files only.
        /// </summary>
        TextOnly,
        /// <summary>
        /// Build list of binary files only.
        /// </summary>
        BinaryOnly
    }

    /// <summary>
    /// Developer file list builder to validate ChuckHill2.ExtensionDetector/LibMagic and accomadate any detection and extension translation issues.
    /// </summary>
    public class BuildList
    {
        private const int ConcurrentThreadCount = -1;  //For Parallel.ForEach(). Change to 1 for debugging, -1 for performance (maximum).

        #region Busy Spinner - Busy()
        private static object busy_lock = new object();
        private static ulong tick_index = 0;
        private static string[] ticks = new string[] { " |\b\b", " /\b\b", " â”€\b\b", " \\\b\b" };
        private static void Busy() { lock (busy_lock) Console.Write(ticks[(tick_index++) % 4]); }
        #endregion  Busy Spinner - Busy()

        /// <summary>
        /// Get info for a single specified file and write results to Console.
        /// </summary>
        /// <param name="file"></param>
        public static void GetFileContent(string file)
        {
            var ext = Path.GetExtension(file);
            string content = FileExtension.ReadText(file,1024)??"[Binary]";
            var detectedMimeType = MagicDetector.LibMagic(file, LibMagicOptions.MimeType);
            var detectedExtension = MagicDetector.LibMagic(file, LibMagicOptions.Extensions);
            var mimeExtension = FileExtension.ByMimetype(detectedMimeType);
            var contentExtension = FileExtension.ByContent(file);
            var detectedDescription = MagicDetector.LibMagic(file, LibMagicOptions.Description);
            var namespaces = FileExtension.BuildListNamespaces(content);
            var indent = "Namespaces:....".Length;
            if (namespaces.Length > (78 - indent))
            {
                //re-format multiple tab-delimited namespaces as newline delimited with indent
                var arr = namespaces.Split(new char[] { '\t' }, StringSplitOptions.RemoveEmptyEntries);
                if (arr.Length < 2) namespaces = arr[0];
                else
                {
                    var sb = new StringBuilder();
                    var nl = string.Empty;
                    var insetStr = string.Empty;
                    foreach (var ns in arr)
                    {
                        sb.Append(insetStr);
                        sb.Append(ns);
                        insetStr = "\r\n"+new String(' ', indent);
                    }
                    namespaces = sb.ToString();
                }
            }

            Console.WriteLine($"File Extensn:  {ext}");
            Console.WriteLine($"Detected Mime: {detectedMimeType}");
            Console.WriteLine($"Detected Ext:  {detectedExtension}");
            Console.WriteLine($"Detected Desc: {detectedDescription}");
            Console.WriteLine($"Exten by Mime: {mimeExtension}");
            Console.WriteLine($"Content Exten: {contentExtension}");
            Console.WriteLine($"Namespaces:    {namespaces}");
            Console.WriteLine($"Content:       {content}");
        }

        /// <summary>
        /// Get info for all files (excluding content duplicates) and write results to tab-delimited text file.
        /// </summary>
        /// <param name="textOnly">True to restrict results to non-binary files. Default=false. This parameter is only recognized when cache TestFiles.txt does not exist.</param>
        public static void FindAllFiles(BuildListOptions options = BuildListOptions.Both)
        {
            FileExtension.EnableDebug = true;

            var destinationFolder = Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName);

            var tempfileListName = Path.Combine(destinationFolder, "TestFiles.temp");
            var fileListName = Path.Combine(destinationFolder, "TestFiles.txt"); //file is overwridden ONLY upon successful completion.
            bool fromFile = FileEx.Exists(fileListName);

            StreamWriter fileListWriter = null;
            if (!fromFile)
            {
                fileListWriter = new StreamWriter(tempfileListName) { AutoFlush = true };
                fileListWriter.WriteLine( "|**************************************************************************");
                fileListWriter.WriteLine($"| BuildList autogenerated file cache, created {DateTime.Now.ToString("g")}");
                fileListWriter.WriteLine( "| This file is automatically created only if it does not exist.");
                fileListWriter.WriteLine( "| Subsequent calls just read this file for the filenames.");
                fileListWriter.WriteLine( "|**************************************************************************");
                fileListWriter.WriteLine();
            }

            Console.WriteLine($"Searching all files in {(fromFile ? $"list \"{Path.GetFileName(fileListName)}\"" : "C: drive")} ...");

            ConcurrentDictionary<string, string> FilesDict = null;
            if (!fromFile) FilesDict = new ConcurrentDictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            var tempoutputFilename = Path.Combine(destinationFolder, "AllFilesList.temp");
            var encoder = Encoding.GetEncoding("UTF-8", new EncoderReplacementFallback("?"), new DecoderReplacementFallback("?"));
            var sw = new StreamWriter(tempoutputFilename, false, encoder) { AutoFlush = true };
            sw.WriteLine("Original Extension\tContent Extension\tMime Extension\tDetected Extension\tDetected Mime Type\tDetected Description\tXML Regex\tFile Content\tFilename\tNameSpaces");

            var poptions = new ParallelOptions() { MaxDegreeOfParallelism = ConcurrentThreadCount };
            if (poptions.MaxDegreeOfParallelism == 1) Console.WriteLine("FindAllFiles: Not running in parallel!");

            int kount = 0;
            IEnumerable<string> filesList = fromFile ? EnumerateFilesList(fileListName) : FileEx.EnumerateFiles(@"C:\", SearchOption.AllDirectories);
            Parallel.ForEach(filesList, poptions, file =>
            {
                string content = null;
                string detectedMimeType = null;
                string detectedDescription = null;
                string ext = null;

                if (!fromFile)
                {
                    if (file.Length > FileEx.MAX_PATH) return;
                    if (file.Contains(@"\$")) return;  //exclude recycle bin
                    ext = Path.GetExtension(file);
                    if (string.IsNullOrEmpty(ext)) return;
                    if (ext == ".log") return; //by definition, these are free-form text files. there are too many are always desiginated as "text/plain"|".txt"
                    //Ignore files with too-long extensions, extensions containing funky characters, or extensions containing all numbers as these likely do not refer to valid filetypes.
                    if (ext.Length > 16 || ext.IndexOfAny(new char[] { '_', ',', '@', '(', '~', '=', '%', ' ' }) != -1 || ext.Substring(1).All(c => c >= '0' && c <= '9')) return;
                    var length = FileEx.Length(file);
                    if (length < 32) return;  //won't detect anything usefull if file is too small. The smallest encountered is "*.url" at 41 bytes.

                    string key;
                    content = FileExtension.ReadText(file);

                    //Always save both text and binary file names but not files with zero-length text after comments are stripped out.
                    if (content == null || (content != null && content.Length > 0))
                        lock (fileListWriter) fileListWriter.WriteLine(file); //save for subsequent runs so we don't have to search the entire C: drive again.

                    if (content == null)
                    {
                        if (options == BuildListOptions.TextOnly) return;
                        detectedMimeType = MagicDetector.LibMagic(file, LibMagicOptions.MimeType);
                        if (detectedMimeType.EndsWith("no read permission")) return;  //file exists but is not readable by LibMagic
                        detectedDescription = MagicDetector.LibMagic(file, LibMagicOptions.Description);
                        content = "[Binary]";

                        key = string.Concat(ext, "|", detectedMimeType, "|", detectedDescription);
                    }
                    else
                    {
                        if (options == BuildListOptions.BinaryOnly) return;
                        if (content.Length == 0) return;
                        // var md5 = new MD5CryptoServiceProvider(); //faster???
                        // var result = new Guid(md5.ComputeHash(Encoding.UTF8.GetBytes(content)));
                        // md5.Dispose();
                        // key = string.Concat(ext, "|", result);

                        key = string.Concat(ext, "|", content);
                    }

                    if (!FilesDict.TryAdd(key, null)) return; //duplicate files are ignored.
                }

                content = content ?? FileExtension.ReadText(file) ?? "[Binary]";
                if (content.Length == 0) return;
                if (detectedMimeType == null)
                {
                    detectedMimeType = MagicDetector.LibMagic(file, LibMagicOptions.MimeType);
                    if (detectedMimeType.EndsWith("no read permission")) return;  //file exists but is not readable by LibMagic
                }
                ext = ext ?? Path.GetExtension(file);
                detectedDescription = detectedDescription ?? MagicDetector.LibMagic(file, LibMagicOptions.Description);
                var detectedExtension = MagicDetector.LibMagic(file, LibMagicOptions.Extensions);
                if (detectedExtension == "???") detectedExtension = "";
                var mimeExtension = FileExtension.ByMimetype(detectedMimeType);
                var xmlRegex = FileExtension.BuildListXmlRegex(content);
                var contentExtension = FileExtension.ByContent(file) ?? string.Empty;
                var namespaces = FileExtension.BuildListNamespaces(content);

                Busy();

                lock (sw)
                {
                    kount++;
                    sw.WriteLine($"{ext}\t{contentExtension}\t{mimeExtension}\t{detectedExtension}\t{detectedMimeType}\t{detectedDescription}\t{xmlRegex}\t{content}\t{file}\t{namespaces}");
                }
            });

            sw.Close();
            fileListWriter?.Close();

            if (kount == 0) Console.WriteLine($"No files found.");
            else
            {
                if (fromFile) Console.WriteLine($"{kount} files scanned.");
                else Console.WriteLine($"{kount} unique files found.");

                //overwrite old files ONLY if successful.

                var outputFilename = Path.ChangeExtension(tempoutputFilename, ".txt");
                File.Delete(outputFilename);
                File.Move(tempoutputFilename, outputFilename);

                File.Delete(fileListName);
                File.Move(tempfileListName, fileListName);
            }
        }

        private static IEnumerable<string> EnumerateFilesList(string sourceFilelist)
        {
            var sr = new StreamReader(sourceFilelist);
            string line;
            while ((line = sr.ReadLine()) != null)
            {
                var i = line.IndexOf('|'); //pipe chosen because it is an illegal filename char
                if (i != -1) line = line.Substring(0, i);
                line = line.Trim();
                if (line.Length == 0) continue;
                if (!FileEx.Exists(line))
                {
                    Debug.WriteLine($"File not found: \"{line}\"");
                    continue;
                }
                yield return line;
            }
            sr.Close();
            yield break;
        }
    }
}
